# Код script.js состоит из следующих основных частей:

1. Загрузка данных с сервера:

- Функция `fetchData()` имитирует асинхронную загрузку данных.

2. Создание строк таблицы:

- Функция `createTableRows()` создает строки таблицы на основе полученных данных.

3. Обработка клика по строке:

- Функция `handleRowClick()` обрабатывает клик по строке таблицы, отображая или скрывая график.

4. Создание `Highcharts` графика:

- Функция `createChart()` формирует график из представленных данных с исользованием библиотеки `Highcharts`.

5. Инициализация:

- Вызов `fetchData()` и последующее создание таблицы после загрузки данных.

## Детальное описание:

### Загрузка данных с сервера:

1. `async function fetchData()` - Объявляет асинхронную функцию `fetchData`, имитирующую получение данных с сервера.

2. `await fetch("./data/data.json");` - Выполняет HTTP-запрос к файлу `./data/data.json`.

3. `if (!response.ok) { throw new Error('HTTP error! status: ${response.status}');}` - Обрабатывает ответ от "сервера".

- Проверяет, чтобы ответ был успешным (`response.ok`). В случае ошибки выбрасывает исключение.

- Использует `response.json();` для преобразования JSON-ответа в объект JavaScript.

### Создание строк таблицы:

1. `function createTableRows(data)` - Объявляет функцию `createTableRows`, принимающую данные для таблицы (`data`) в качестве аргумента.

2. `data.forEach((row, index) => { ... })` - Метод `forEach` перебирает каждый элемент массива `data` (данные для таблицы).

3. Внутри цикла:

- `row` - текущий объект данных из массива `data`.
- `index` - индекс текущего элемента в массиве.
- `const tr = document.createElement("tr");` - Создает новый элемент `<tr>` (строка таблицы).
- `tr.innerHTML = \…;` - Заполняет строку данными из текущего объекта `row`.

#### Используется шаблонная строка для удобного добавления HTML:

- `<td>${row.indicator}</td>` - Ячейка для названия показателя.
- `<td>${formatNumber(row.currentDay)}</td>` - Ячейка для текущего значения (отформатированного с помощью `formatNumber`).
- `<td> <span class="number-cell">${formatNumber(row.yesterday)}</span>` и `<span style="float: right;" class="${percentageClass}">${percentageChange}</span></td>`- Ячейка со значением за вчерашний день и процентным изменением. Вложенные span для выравнивания.
- `<td>${formatNumber(row.thisDayLastWeek)}</td>` - Ячейка для значения на этой неделе (отформатированного с помощью `formatNumber`).

3.  `tr.dataset.chartIndex = index;` - Сохраняет индекс элемента `index` в `data` атрибуте `data-chart-index`.

4.  `tr.addEventListener("click", () => handleRowClick(row, index));` - Добавляет обработчик события `click` на созданную строку `<tr>`.

- При клике будет вызвана функция `handleRowClick`, передавая ей объект данных `row` и `index` строки.

5. `tableBody.appendChild(tr);` - Добавляет созданную строку `<tr>` в элемент `<tbody>` таблицы (полученный ранее по `id tableBody`).

### Обработка клика по строке:

1. `function handleRowClick(row, index)` - объявляет функцию `handleRowClick`, принимающую объект данных `row` и `index` строки в качестве аргументов.

2. `const chartContainerId = 'chart-container-${index}';` - Формирует уникальный `id` для элемента контейнера графика.

3. `const chartContainerDiv = document.createElement("tr");` - Создает элемент `<tr>` для графика.

4. `chartContainerDiv.innerHTML = \` - Заполняет созданный элемент строкой с контейнером для графика

5. Управление открытой строкой:

- Проверяет была ли открыта строка с графиком `if(currentlyOpenChartRow)`.
- Если была, и индекс этой строки тот же, что и у кликнутой - закрывает график, убирая строку.
- Если строка была, но индекс другой, то удаляет предыдущую строку с графиком.

6. `const clickedRow = tableBody.querySelector(\tr[data-chart-index=”${index}”])` - Получает ссылку на элемент строки на которую кликнули.

7. `clickedRow.insertAdjacentElement('afterend', chartContainerDiv);` - Вставляет строку с графиком после строки, на которую кликнули.

8. `const chartContainer = chartContainerDiv.querySelector('.chart-container')` - Получает доступ к контейнеру графика. Анимирует появление графика, присваивая стили.

9. `if (chart) { chart.destroy();}` - Удаляет старый график (если есть).

10. `chart = createChart(chartContainerId, row.data, row.indicator);` - Создает новый график с помощью библиотеки `Highcharts`. Сохраняет ссылку на открытую строку в currentlyOpenChartRow.

### Отрисовка графика Highcharts

Функция `createChart(containerId, data, indicator)` - отвечает за создание и отрисовку графика Highcharts на основе предоставленных данных:

1. `return Highcharts.chart(containerId, { ... });` - Ядро функции - вызывает метод Highcharts.chart(), который создает и отрисовывает график Highcharts.

2. `containerId:` - `id` элемента HTML-контейнера, в котором будет отображен график.

3. `{ ... }`- объект конфигурации, определяющий внешний вид и поведение графика.

- Highcharts интерпретирует этот объект, чтобы знать, какой график нужно создать.
- `chart: { type: "line", height: "400px", }` - раздел конфигурации задает тип графика (линейный) и его высоту (400 пикселей).

4. `title: { text: \График для показателя “${indicator}”, }`- Устанавливает заголовок графика.

- Значение заголовка динамически формируется, используя переданное значение indicator.

5. `xAxis: { categories: [ ... ] }` - Определяет ось абсцисс (ось X).

6. `categories:` - Массив строк, представляющих категории или метки по оси `X`.

- В данном случае, это дни недели (День 1, День 2 и т.д.).

7. `yAxis: { title: { text: "Значение", } }` - Устанавливает заголовок оси ординат (ось `Y`) с текстом “Значение”.

8. `series: [{ name: indicator, data: data, }]` - Определяет серию данных, которые нужно отобразить на графике.

9. `name:` - Название серии (показывается в легенде) - значение `indicator`.

10. `data:` - Массив значений, которые будут отображены на графике. Это массив, полученный в качестве параметра `data` функции.

## Инициализация:

1. `fetchData().then((data) => { createTableRows(data); });` - Вызывает асинхронную функцию `fetchData` для загрузки данных.

- После успешной загрузки данных вызывается функция `createTableRows` для отрисовки таблицы на странице, передавая данные из `fetchData` в качестве аргумента.

## Вспомогательные функции

### Расчет процентного изменения

Функция `calculatePercentageChange(current, yesterday)` вычисляет процентное изменение между двумя значениями (`current` и `yesterday`):

1. `if (yesterday === 0)` - Проверка, является ли вчерашнее значение равным нулю.
2. `return current === 0 ? "0%" : "∞";` - В случае, если вчерашнее значение равно нулю, возвращает `0%` если текущее значение также равно нулю, а иначе возвращает `∞` (бесконечность), что обычно указывает на ситуацию, когда нет предыдущего значения для расчета процента изменения.
3. `const change = ((current - yesterday) / yesterday) \* 100;` - Выполняет основное вычисление процентного изменения:

- `(current - yesterday)` - Вычисляет разницу между текущим и вчерашним значениями.
- `/ yesterday` - Делит разницу на вчерашнее значение.
- `*100` - Получает процентное изменение.

4.  `return ${change > 0 ? “+” : “”}${change.toFixed(0)}%;` - Формирует и возвращает строковое представление результата:

- `change > 0 ? "+" : ""` - Проверяет, положительно или отрицательно изменение.
- Если положительно, возвращает `+`, иначе возвращает пустую строку.
- `change.toFixed(0)` - Округляет вычисленное изменение до целого числа, чтобы процентное изменение отображалось корректно (без дробей).
- `%` - Добавляет символ процента к результату.

5. `${...}` - Используется шаблонная строка для эффективного конкатенации частей результата.

6. `formatNumber(number)` - Функция форматирования чисел с разделителями тысяч.
